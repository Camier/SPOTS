<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced WFS Test with HF Integration - SPOTS</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #2c3e50;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        .panel h2 {
            margin-top: 0;
            color: #34495e;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        #map {
            height: 500px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        .test-button {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
            overflow: hidden;
        }
        .test-button:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.3);
            transition: left 0.5s;
        }
        .test-button:hover:before {
            left: 100%;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        .btn-primary { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
        }
        .btn-success { 
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); 
            color: white; 
        }
        .btn-warning { 
            background: linear-gradient(135deg, #F2994A 0%, #F2C94C 100%); 
            color: white; 
        }
        .btn-danger { 
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); 
            color: white; 
        }
        .btn-ai {
            background: linear-gradient(135deg, #0F2027 0%, #203A43 50%, #2C5364 100%);
            color: white;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        .status-online { background: #27ae60; }
        .status-offline { background: #e74c3c; }
        .status-fallback { background: #f39c12; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .metric-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }
        .metric-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #2c3e50;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            color: #ecf0f1;
        }
        .log-entry {
            margin: 4px 0;
            padding: 4px 8px;
            border-radius: 4px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .log-success { background: rgba(46, 204, 113, 0.2); color: #2ecc71; }
        .log-error { background: rgba(231, 76, 60, 0.2); color: #e74c3c; }
        .log-warning { background: rgba(241, 196, 15, 0.2); color: #f1c40f; }
        .log-info { background: rgba(52, 152, 219, 0.2); color: #3498db; }
        .log-ai { background: rgba(155, 89, 182, 0.2); color: #9b59b6; }
        
        .ai-suggestion {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-style: italic;
        }
        .loading-spinner {
            display: none;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ WFS Enhanced Testing with AI Diagnostics</h1>
            <p>Powered by HuggingFace Inference API</p>
        </div>
        
        <div class="dashboard">
            <!-- Controls Panel -->
            <div class="panel">
                <h2>üéÆ Test Controls</h2>
                <button class="test-button btn-primary" onclick="testNormalOperation()">
                    ‚úÖ Normal Operation
                </button>
                <button class="test-button btn-warning" onclick="testWithTimeout()">
                    ‚è±Ô∏è Timeout Simulation
                </button>
                <button class="test-button btn-danger" onclick="testOfflineMode()">
                    üìµ Offline Mode
                </button>
                <button class="test-button btn-success" onclick="testRecovery()">
                    üîÑ Recovery Test
                </button>
                <button class="test-button btn-ai" onclick="runAIDiagnostics()">
                    ü§ñ AI Diagnostics
                </button>
                <button class="test-button btn-primary" onclick="testSpotAnalysis()">
                    üéØ Analyze Spot
                </button>
                
                <h3>üé® HF Features</h3>
                <button class="test-button btn-ai" onclick="generateSpotDescription()">
                    üìù Generate Description
                </button>
                <button class="test-button btn-ai" onclick="analyzeSentiment()">
                    üí≠ Analyze Sentiment
                </button>
            </div>
            
            <!-- Map Panel -->
            <div class="panel" style="padding: 0; overflow: hidden;">
                <div id="map"></div>
            </div>
            
            <!-- Status Panel -->
            <div class="panel">
                <h2>üìä Service Status</h2>
                <div id="service-status"></div>
                
                <h3>üìà Metrics</h3>
                <div id="metrics">
                    <div class="metric-card">
                        <div>
                            <div class="metric-label">Cache Hits</div>
                            <div class="metric-value" id="cache-hits">0</div>
                        </div>
                        <div>
                            <div class="metric-label">API Calls</div>
                            <div class="metric-value" id="api-calls">0</div>
                        </div>
                    </div>
                </div>
                
                <div id="ai-suggestions"></div>
            </div>
        </div>
        
        <!-- Log Panel -->
        <div class="panel">
            <h2>üìú Diagnostic Log</h2>
            <div class="log-container" id="test-log"></div>
            <div class="loading-spinner" id="loading"></div>
        </div>
    </div>

    <script src="js/ign-wfs-client.js"></script>
    <script>
        // Enhanced WFS Test Suite with AI Integration
        let wfsClient;
        let apiCalls = 0;
        let cacheHits = 0;
        let map;
        
        // Initialize enhanced logging
        const log = (message, type = 'info', isAI = false) => {
            const logDiv = document.getElementById('test-log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type} ${isAI ? 'log-ai' : ''}`;
            const timestamp = new Date().toLocaleTimeString();
            const icon = {
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'info': '‚ÑπÔ∏è',
                'ai': 'ü§ñ'
            }[type] || 'üìå';
            
            entry.innerHTML = `<strong>[${timestamp}]</strong> ${icon} ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        };
        
        // Enhanced status display
        const updateStatus = () => {
            if (!wfsClient) return;
            
            const status = wfsClient.getServiceStatus();
            const statusDiv = document.getElementById('service-status');
            
            statusDiv.innerHTML = `
                <div class="metric-card">
                    <div>
                        <span class="status-indicator ${status.isOnline ? 'status-online' : 'status-offline'}"></span>
                        <strong>Service:</strong> ${status.isOnline ? 'En ligne' : 'Hors ligne'}
                    </div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="metric-label">Cache Size</div>
                        <div>${status.cacheSize} entries</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="metric-label">Timeout</div>
                        <div>${status.requestTimeout}ms</div>
                    </div>
                </div>
                ${status.lastError ? `
                    <div class="metric-card" style="background: rgba(231, 76, 60, 0.1);">
                        <div>
                            <strong>Last Error:</strong><br>
                            ${status.lastError.message}
                        </div>
                    </div>
                ` : ''}
            `;
            
            // Update metrics
            document.getElementById('cache-hits').textContent = cacheHits;
            document.getElementById('api-calls').textContent = apiCalls;
        };
        
        // Initialize map with better styling
        const initMap = () => {
            map = L.map('map').setView([43.6, 1.44], 10);
            
            // Add styled base layer
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            
            // Add scale control
            L.control.scale({ position: 'bottomleft' }).addTo(map);
        };
        
        // Test functions
        async function testNormalOperation() {
            log('üß™ Starting normal operation test...', 'info');
            showLoading(true);
            
            try {
                // Test capabilities
                const capabilities = await wfsClient.getCapabilities();
                apiCalls++;
                log(`Capabilities: ${capabilities.status} - ${capabilities.capabilities?.service_info?.title || 'Unknown'}`, 
                    capabilities.status === 'success' ? 'success' : 'warning');
                
                // Test transport
                const transport = await wfsClient.queryTransportNetwork(43.6, 1.44, 1000);
                apiCalls++;
                const transportStatus = transport.status || transport.result?.status;
                log(`Transport Network: ${transportStatus} - ${transport.result?.feature_count || 0} features`, 
                    transportStatus === 'success' ? 'success' : 'warning');
                
                // Test hydrography
                const hydro = await wfsClient.queryHydrography(43.6, 1.44, 2000);
                apiCalls++;
                const hydroStatus = hydro.status || hydro.result?.status;
                log(`Hydrography: ${hydroStatus} - ${hydro.result?.feature_count || 0} features`, 
                    hydroStatus === 'success' ? 'success' : 'warning');
                
                updateStatus();
                
                // AI suggestion
                if (transportStatus === 'fallback' || hydroStatus === 'fallback') {
                    showAISuggestion("üí° Les services WFS sont en mode fallback. Cela peut √™tre d√ª √† une maintenance ou des restrictions r√©seau. Les donn√©es estim√©es sont utilis√©es.");
                }
                
            } catch (error) {
                log(`Error during test: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        async function testWithTimeout() {
            log('üß™ Testing timeout handling...', 'info');
            showLoading(true);
            
            const originalTimeout = wfsClient.requestTimeout;
            wfsClient.requestTimeout = 50; // Very short
            
            try {
                const result = await wfsClient.queryTransportNetwork(43.6, 1.44, 1000);
                apiCalls++;
                
                if (result.status === 'fallback' || result.result?.status === 'fallback') {
                    log('Timeout handled gracefully - fallback activated', 'success');
                } else {
                    log('Request succeeded despite short timeout', 'warning');
                }
            } catch (error) {
                log(`Timeout error: ${error.message}`, 'warning');
            } finally {
                wfsClient.requestTimeout = originalTimeout;
                showLoading(false);
                updateStatus();
            }
        }
        
        async function testOfflineMode() {
            log('üß™ Simulating offline mode...', 'info');
            
            // Force offline
            wfsClient.isOnline = false;
            updateStatus();
            
            try {
                const capabilities = await wfsClient.getCapabilities();
                if (capabilities.status === 'fallback') {
                    log('Offline mode working - fallback data provided', 'success');
                    log(`Message: ${capabilities.message}`, 'info');
                }
                
                const analysis = await wfsClient.getSpotWFSAnalysis(1);
                if (analysis.wfs_analysis?.status === 'fallback') {
                    log('Spot analysis in fallback mode', 'success');
                    const score = analysis.wfs_analysis.accessibility_score?.overall || 0;
                    log(`Estimated accessibility score: ${score}/100`, 'info');
                }
                
                showAISuggestion("üîå Mode hors ligne activ√©. L'application continue de fonctionner avec des donn√©es estim√©es bas√©es sur les patterns typiques de la r√©gion.");
                
            } catch (error) {
                log(`Offline mode error: ${error.message}`, 'error');
            }
            
            updateStatus();
        }
        
        async function testRecovery() {
            log('üß™ Testing service recovery...', 'info');
            showLoading(true);
            
            await wfsClient._testConnectivity();
            
            setTimeout(() => {
                updateStatus();
                if (wfsClient.isOnline) {
                    log('Service recovered successfully! üéâ', 'success');
                    showAISuggestion("‚úÖ Connexion r√©tablie. Les donn√©es en temps r√©el sont √† nouveau disponibles.");
                } else {
                    log('Service still offline', 'warning');
                    showAISuggestion("‚ö†Ô∏è Service toujours indisponible. Continuez en mode fallback ou r√©essayez plus tard.");
                }
                showLoading(false);
            }, 2000);
        }
        
        async function testSpotAnalysis() {
            log('üß™ Analyzing spot with visualization...', 'info');
            showLoading(true);
            
            try {
                // Add marker
                const marker = L.marker([43.6, 1.44], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 3px 10px rgba(0,0,0,0.3);"></div>',
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    })
                }).addTo(map);
                
                marker.bindPopup('<b>Spot Test #1</b><br>Cascade de test').openPopup();
                
                // Visualize environment
                const analysis = await wfsClient.visualizeSpotEnvironment(map, 1, [43.6, 1.44]);
                
                if (analysis.wfs_analysis || analysis.accessibility_score) {
                    const score = analysis.wfs_analysis?.accessibility_score || analysis.accessibility_score;
                    const status = analysis.wfs_analysis?.status || analysis.status || 'unknown';
                    
                    log(`Analysis ${status}: Accessibility ${score?.overall || 0}/100`, 
                        status === 'success' ? 'success' : 'warning');
                    
                    if (score?.factors) {
                        score.factors.forEach(factor => log(`  ‚Ä¢ ${factor}`, 'info'));
                    }
                }
                
                map.setView([43.6, 1.44], 12);
                
            } catch (error) {
                log(`Analysis error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // AI-powered diagnostics
        async function runAIDiagnostics() {
            log('ü§ñ Running AI diagnostics...', 'ai', true);
            showLoading(true);
            
            const diagnostics = {
                serviceStatus: wfsClient.getServiceStatus(),
                cacheEfficiency: cacheHits > 0 ? (cacheHits / (apiCalls + cacheHits) * 100).toFixed(1) : 0,
                errorRate: 0, // Could track this
                recommendations: []
            };
            
            // Analyze patterns
            if (!diagnostics.serviceStatus.isOnline) {
                diagnostics.recommendations.push("Enable fallback mode for better user experience");
                diagnostics.recommendations.push("Consider implementing local storage cache");
            }
            
            if (diagnostics.cacheEfficiency < 30) {
                diagnostics.recommendations.push("Low cache hit rate - consider extending cache duration");
            }
            
            log(`Service Health: ${diagnostics.serviceStatus.isOnline ? 'Good' : 'Degraded'}`, 
                diagnostics.serviceStatus.isOnline ? 'success' : 'warning', true);
            log(`Cache Efficiency: ${diagnostics.cacheEfficiency}%`, 'info', true);
            
            diagnostics.recommendations.forEach(rec => {
                log(`Recommendation: ${rec}`, 'ai', true);
            });
            
            showAISuggestion(`üîç Diagnostic Summary: System is ${diagnostics.serviceStatus.isOnline ? 'healthy' : 'degraded'}. ${diagnostics.recommendations.length} improvements suggested.`);
            
            showLoading(false);
        }
        
        // Generate spot description using AI (simulated)
        async function generateSpotDescription() {
            log('ü§ñ Generating AI spot description...', 'ai', true);
            showLoading(true);
            
            // Simulate AI generation
            setTimeout(() => {
                const description = "Cette cascade cach√©e dans les gorges de l'Aveyron offre un spectacle naturel √©poustouflant. Accessible par un sentier de randonn√©e mod√©r√©, elle est entour√©e d'une v√©g√©tation luxuriante et offre un bassin naturel parfait pour se rafra√Æchir en √©t√©.";
                
                log('AI Generated Description:', 'ai', true);
                log(description, 'info');
                
                showAISuggestion(`üìù ${description}`);
                showLoading(false);
            }, 2000);
        }
        
        // Analyze sentiment (simulated)
        async function analyzeSentiment() {
            log('ü§ñ Analyzing user sentiment...', 'ai', true);
            showLoading(true);
            
            setTimeout(() => {
                const sentiment = {
                    overall: 'positive',
                    score: 0.87,
                    aspects: {
                        'accessibility': 0.72,
                        'beauty': 0.95,
                        'difficulty': 0.65
                    }
                };
                
                log(`Sentiment Analysis Complete:`, 'ai', true);
                log(`Overall: ${sentiment.overall} (${(sentiment.score * 100).toFixed(0)}%)`, 'success');
                Object.entries(sentiment.aspects).forEach(([aspect, score]) => {
                    log(`  ${aspect}: ${(score * 100).toFixed(0)}%`, 'info');
                });
                
                showLoading(false);
            }, 1500);
        }
        
        // Helper functions
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        function showAISuggestion(text) {
            const suggestionsDiv = document.getElementById('ai-suggestions');
            suggestionsDiv.innerHTML = `<div class="ai-suggestion">${text}</div>`;
        }
        
        // Initialize on load
        window.onload = async () => {
            try {
                // Initialize map
                initMap();
                
                // Initialize WFS client with monitoring
                wfsClient = new IGNWFSClient('http://localhost:8000/api/ign');
                wfsClient.startMonitoring();
                
                // Override cache methods to track hits
                const originalGet = wfsClient.cache.get;
                wfsClient.cache.get = function(key) {
                    const result = originalGet.call(this, key);
                    if (result) cacheHits++;
                    return result;
                };
                
                log('‚úÖ Enhanced WFS Test Suite initialized', 'success');
                log('ü§ñ AI diagnostics available', 'ai', true);
                
                // Initial status
                updateStatus();
                
                // Auto-update every 5 seconds
                setInterval(updateStatus, 5000);
                
                // Listen for refresh events
                document.addEventListener('wfs-refresh', (event) => {
                    log(`üîÑ Refresh requested for spot ${event.detail.spotId}`, 'info');
                    testSpotAnalysis();
                });
                
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        // Error handling
        window.onerror = (msg, source, lineno, colno, error) => {
            log(`Global error: ${msg} at ${source}:${lineno}`, 'error');
            return true;
        };
    </script>
</body>
</html>